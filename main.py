# us
import array
import hashlib
import math
import Ui_aboutUs
import multiprocessing
import os
import pickle
import platform
from posixpath import basename
import string
import sys
import time
import webbrowser
from datetime import datetime
from re import I
from threading import Thread
import pefile
import psutil
import win32file
from playsound import playsound
from PySide6.QtCore import (QCoreApplication, QObject, QRunnable, Qt,
                            QThreadPool, Signal, Slot)
from PySide6.QtGui import QAction, QBrush, QColor, QFont, QIcon
from PySide6.QtWidgets import (QFileDialog, QListWidgetItem, QMenu,
                               QSystemTrayIcon,QDialog)
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer
from PySide6 import QtCore
import Ui_smartMalwareDetection
ui = Ui_smartMalwareDetection.Ui_MainWindow()

class MySignal(QObject):
    sig = Signal(str)
signal = MySignal()
try:
    ignorFiles=[i.strip() for i in open('Ignore.txt','r')]
except Exception as e:
    print(e)
    ignorFiles=[]
try:
    virusChest=set([i.strip() for i in open('virusChest.txt','r')])
except Exception as e:
    print(e)
    virusChest=set()
shared=None;totalThreadShared=None;fileScanedShared=None;dragPos=''
threadpool=QThreadPool()
lockFiles = [i.strip().split(',')[0] for i in open('qurantine.txt','r').readlines()]
class Worker(QRunnable):
    def __init__(self,fn,*args, **kwargs):
        super().__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
    @Slot()
    def run(self):
        self.fn(*self.args,**self.kwargs)


def hashing(file):
    # BUF_SIZE is totally arbitrary, change for your app!
    BUF_SIZE = 65536  # lets read stuff in 64kb chunks!
    md5 = hashlib.md5()
    sha1 = hashlib.sha256()
    with open(file, 'rb') as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break
            md5.update(data)
            sha1.update(data)
    return md5.hexdigest(),sha1.hexdigest()


def get_entropy(data):
    '''Information Entropy or Shannon's entropy quantifies the amount of uncertainty (or surprise) involved in the value of a random variable or the outcome of a random process.'''
    try:
        if len(data) == 0:
            return 0.0
        occurences = array.array('L', [0]*256)
        for x in data:
            occurences[x if isinstance(x, int) else ord(x)] += 1
    
        entropy = 0
        for x in occurences:
            if x:
                p_x = float(x) / len(data)
                entropy -= p_x*math.log(p_x, 2)
    
        return entropy
    except:
        return 0.0


def get_resources(pe):
    '''resources are read-only data embedded in portable executable files like EXE, DLL, CPL, SCR, SYS or (beginning with Windows Vista) MUI files'''
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)
                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources


def get_version_info(pe):
    res = []
    try:
        for fileinfo in pe.FileInfo:
                for st in fileinfo[0].StringTable:
                    for entry in st.entries.items():
                        res.append(entry[1])
                for var in fileinfo[1].Var:
                    res.append(var)
        if hasattr(pe, 'VS_FIXEDFILEINFO'):
            res.append(pe.VS_FIXEDFILEINFO[0].FileFlags)
            res.append(pe.VS_FIXEDFILEINFO[0].FileOS)
            res.append(pe.VS_FIXEDFILEINFO[0].FileType)
            res.append(pe.VS_FIXEDFILEINFO[0].FileVersionLS)
            res.append( pe.VS_FIXEDFILEINFO[0].ProductVersionLS)
            res.append(pe.VS_FIXEDFILEINFO[0].Signature)
            res.append( pe.VS_FIXEDFILEINFO[0].StrucVersion)
        return res
    except:
        return res


def classficationQuickScan(extract_features,get_resources,get_entropy,get_version_info,shared,fileScanedShared,totalThreadShared,hashing):
    try:
        clf = pickle.load(open('CLF_RandomForest_99.2.sav', 'rb'))
        paths=[]
        desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop') 
        download = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Downloads') 
        for root, dirs, files in os.walk(desktop):
            for file in files:
                if file in ignorFiles:
                    continue
                paths.append(os.path.join(root,file))
        for root, dirs, files in os.walk(download):
            for file in files:
                if file in ignorFiles:
                    continue
                paths.append(os.path.join(root,file))
        progress=0;totalFiles=len(paths);totalThread=0;totalFileScaned=0
        print(len(paths))
        f=open('QuickScanResults.txt','a+')
        for j,i in enumerate(paths):
            file = i.replace('\\','/')
            try:
                checkExe = open(file,"rb")
            except:
                pass
            try:
                if checkExe.read(2) == b'MZ':
                    prediction=clf.predict([extract_features(pefile.PE(file))])
                    if prediction[0]==0:
                        prediction='Malware'
                        if prediction=='Malware':
                            totalThread+=1
                            totalThreadShared.put(totalThread)
                    else:
                        prediction='Clean'
                    if prediction=='Malware':
                        f.write(f'{file}\n')
            except:
                pass
            time.sleep(0.5)
            totalFileScaned+=1
            fileScanedShared.put(totalFileScaned)
            progress=int(((j+1)/totalFiles)*100)
            shared.put(progress)
        f.close()
    except Exception as e:
        print(e)


def classificationCustomScan(extract_features,get_resources,get_entropy,get_version_info,shared,dir):
    try:
        clf = pickle.load(open('CLF_RandomForest_99.2.sav', 'rb'))
        paths=[]
        for root, dirs, files in os.walk(dir):
            for file in files:
                if file in ignorFiles:
                    continue
                paths.append(os.path.join(root,file))
        progress=0;totalFiles=len(paths)
        f=open('CustomScanResults.txt','a+')
        for j,i in enumerate(paths):
            file = i.replace('\\','/')
            try:
                checkExe = open(file,"rb")
                if checkExe.read(2) == b'MZ':
                    prediction=clf.predict([extract_features(pefile.PE(file))])
                    if prediction[0]==0:
                        prediction='Malware'
                    else:
                        prediction='Clean'
                    if prediction=='Malware':
                        f.write(f'{file}\n')
            except Exception as e:
                print(e)
            time.sleep(0.5)
            progress=int(((j+1)/totalFiles)*100)
            shared.put(progress)
        f.close()
    except:
        pass
    

def classficationDeepScan(extract_features,get_resources,get_entropy,get_version_info,shared,fileScanedShared,totalThreadShared,hashing):
    try:
        clf = pickle.load(open('CLF_RandomForest_99.2.sav', 'rb'))
        paths=[]
        drives = ['%s:' % d for d in string.ascii_uppercase if os.path.exists('%s:' % d)]
        for i in drives[1:]:
            for root, dirs, files in os.walk(f'{i}/'):
                for file in files:
                    if file in ignorFiles:
                        continue
                    paths.append(os.path.join(root,file))
        progress=0;totalFiles=len(paths);totalThread=0;totalFileScaned=0
        print(len(paths))
        f=open('DeepScanResults.txt','a+')
        for j,i in enumerate(paths):
            file = i.replace('\\','/')
            try:
                checkExe = open(file,"rb")
                if checkExe.read(2) == b'MZ':
                    prediction=clf.predict([extract_features(pefile.PE(file))])
                    if prediction[0]==0:
                        prediction='Malware'
                        if prediction=='Malware':
                            totalThread+=1
                            totalThreadShared.put(totalThread)
                    else:
                        prediction='Clean'
                    if prediction=='Malware':
                        f.write(f'{file}\n')
                time.sleep(0.5)
                totalFileScaned+=1
                fileScanedShared.put(totalFileScaned)
                progress=int(((j+1)/totalFiles)*100)
                shared.put(progress)
            except Exception as e:
                print(e)
    except Exception as e:
        print(e)
    f.close()


def extract_features(pe):
    feature_list=[]
    try:
        '''The Machine field has one of the following values, which specify the CPU type. An image file can be run only on the specified machine or on a system that emulates the specified machine.'''
        feature_list.append(int(pe.FILE_HEADER.Machine))
    except:
        feature_list.append(0)
    try:
        '''Every image file has an optional header that provides information to the loader.'''
        feature_list.append(int(pe.FILE_HEADER.SizeOfOptionalHeader))
    except:
        feature_list.append(0)
    try:
        '''The Characteristics field contains flags that indicate attributes of the object or image file. The following flags are currently defined:'''
        feature_list.append(int(pe.FILE_HEADER.Characteristics))
    except:
        feature_list.append(0)
    try:
        '''The first eight fields of the optional header are standard fields that are defined for every implementation of COFF. These fields contain general information that is useful for loading and running an executable file.'''
        feature_list.append(int(pe.OPTIONAL_HEADER.MajorLinkerVersion))
    except:
        feature_list.append(0)
    try:
        feature_list.append(int(pe.OPTIONAL_HEADER.MinorLinkerVersion))
    except:
        feature_list.append(0)
    try:
        '''The size of the code (text) section, or the sum of all code sections if there are multiple sections. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfCode))
    except:
        feature_list.append(0)
    try:
        '''The size of the initialized data section, or the sum of all such sections if there are multiple data sections. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfInitializedData))
    except:
        feature_list.append(0)
    try:
        '''The size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfUninitializedData))
    except:
        feature_list.append(0)
    try:
        feature_list.append(int(pe.OPTIONAL_HEADER.AddressOfEntryPoint))
    except:
        feature_list.append(0)
    try:
        '''The address that is relative to the image base of the beginning-of-code section when it is loaded into memory. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.BaseOfCode))
    except:
        feature_list.append(0)
    try:
        '''The address that is relative to the image base of the beginning-of-data section when it is loaded into memory. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.BaseOfData))
    except:
        feature_list.append(0)
    try:
        '''The preferred address of the first byte of image when loaded into memory; must be a multiple of 64 K. The default for DLLs is 0x10000000. The default for Windows CE EXEs is 0x00010000. The default for Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98, and Windows Me is 0x00400000. '''    
        feature_list.append(int(pe.OPTIONAL_HEADER.ImageBase))
    except:
        feature_list.append(0)
    try:
        '''The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to FileAlignment. The default is the page size for the architecture. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SectionAlignment))
    except:
        feature_list.append(0)
    try:
        '''The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64 K, inclusive. The default is 512. If the SectionAlignment is less than the architecture's page size, then FileAlignment must match '''
        feature_list.append(int(pe.OPTIONAL_HEADER.FileAlignment))
    except:
        feature_list.append(0)
    try:
        '''The major version number of the required operating system. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion))
    except:
        feature_list.append(0)
    try:
        '''The minor version number of the required operating system. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion))
    except:
        feature_list.append(0)
    try:
        '''The major version number of the image. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.MajorImageVersion))
    except:
        feature_list.append(0)
    try:
        '''The minor version number of the image.'''
        feature_list.append(int(pe.OPTIONAL_HEADER.MinorImageVersion))
    except:
        feature_list.append(0)
    try:
        feature_list.append(int(pe.OPTIONAL_HEADER.MajorSubsystemVersion))
    except:
        feature_list.append(0)
    try:
        feature_list.append(int(pe.OPTIONAL_HEADER.MinorSubsystemVersion))
    except:
        feature_list.append(0)
    try:
        '''The size (in bytes) of the image, including all headers, as the image is loaded in memory. It must be a multiple of SectionAlignment.'''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfImage))
    except:
        feature_list.append(0)
    try:
        """The combined size of an MS-DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment. """
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfHeaders))
    except:
        feature_list.append(0)
    try:
        '''The image file checksum. The algorithm for computing the checksum is incorporated into IMAGHELP.DLL. The following are checked for validation at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded into a critical Windows process. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.CheckSum))
    except:
        feature_list.append(0)
    try:
        '''The subsystem that is required to run this image. For more information'''
        feature_list.append(int(pe.OPTIONAL_HEADER.Subsystem))
    except:
        feature_list.append(0)
    try:
        '''Dynamic Link Liberary Characterstcis'''
        feature_list.append(int(pe.OPTIONAL_HEADER.DllCharacteristics))
    except:
        feature_list.append(0)
    try:
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfStackReserve))
    except:
        feature_list.append(0)
    try:
        '''The size of the stack to commit. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfStackCommit))
    except:
        feature_list.append(0)
    try:
        '''The size of the local heap space to reserve. Only SizeOfHeapCommit is committed; the rest is made available one page at a time until the reserve size is reached. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfHeapReserve))
    except:
        feature_list.append(0)
    try:
        '''The size of the local heap space to commit. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.SizeOfHeapCommit))
    except:
        feature_list.append(0)
    try:
        '''Reserved, must be zero. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.LoaderFlags))
    except:
        feature_list.append(0)
    try:
        '''The number of data-directory entries in the remainder of the optional header. Each describes a location and size. '''
        feature_list.append(int(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes))
    except:
        feature_list.append(0)
    try:
        '''The number of entries in the section table is given by the NumberOfSections field in the file header'''
        feature_list.append(int(pe.FILE_HEADER.NumberOfSections))
    except:
        feature_list.append(0)
    sectionEntropies=[]
    sectionRawDataSize=[]
    sectionVirtualSize=[]
    for section in pe.sections:
        try:
            sectionEntropies.append(section.get_entropy())
        except:
            pass
        try:
            sectionRawDataSize.append(section.SizeOfRawData)
        except:
            pass
        try:
            sectionVirtualSize.append(section.Misc_VirtualSize)
        except:
            pass
    try:
        feature_list.append(round(float(sum(sectionEntropies)/len(sectionEntropies)),11))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(min(sectionEntropies),12))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(max(sectionEntropies),11))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(float(sum(sectionRawDataSize)/len(sectionRawDataSize)),11))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(min(sectionRawDataSize),12))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(max(sectionRawDataSize),12))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(float(sum(sectionVirtualSize)/len(sectionVirtualSize)),11))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(min(sectionVirtualSize),12))
    except:
        feature_list.append(0)
    try:
        feature_list.append(round(max(sectionVirtualSize),12))
    except:
        feature_list.append(0)
    importedDLLs=[]
    try:
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            importedDLLs.append(entry.dll.decode('utf-8'))
    except:
        pass
    try:
        feature_list.append(len(importedDLLs))
    except:
        feature_list.append(0)
    numberOfImports=[]
    try:
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode('utf-8')
            for func in entry.imports:
                numberOfImports.append(func)
    except:
        pass
    try:
        feature_list.append(len(numberOfImports))
    except:
        feature_list.append(0)
    callByOrdinal=[]
    try:
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            for imp in entry.imports:
                if imp.ordinal != None:
                    callByOrdinal.append(imp.ordinal)
    except:
        pass
    
    try:
        feature_list.append(len(callByOrdinal))
    except:
        feature_list.append(0)
    try:
        pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]])
        NumbeOfexports = [(e.ordinal, e.name) for e in pe.DIRECTORY_ENTRY_EXPORT.symbols][0][0]
        feature_list.append(NumbeOfexports)
    except:
        feature_list.append(0)
    numberOfResouces=[]
    try:
        for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
            for i in rsrc.directory.entries:
                numberOfResouces.append(i)
    except:
        pass
    try:
        feature_list.append(len(numberOfResouces))
    except:
        feature_list.append(0)

    res={}
    resources= get_resources(pe)
    if len(resources)> 0:
        entropy = list(map(lambda x:x[0], resources))
        res['ResourcesMeanEntropy'] = sum(entropy)/float(len(entropy))
        res['ResourcesMinEntropy'] = min(entropy)
        res['ResourcesMaxEntropy'] = max(entropy)
        sizes = list(map(lambda x:x[1], resources))
        res['ResourcesMeanSize'] = sum(sizes)/float(len(sizes))
        res['ResourcesMinSize'] = min(sizes)
        res['ResourcesMaxSize'] = max(sizes)
    else:
        res['ResourcesMeanEntropy'] = 0
        res['ResourcesMinEntropy'] = 0
        res['ResourcesMaxEntropy'] = 0
        res['ResourcesMeanSize'] = 0
        res['ResourcesMinSize'] = 0
        res['ResourcesMaxSize'] = 0
    for i in res.values():
        feature_list.append(round(i,11))
    try:
        LoadConfigureationsize=pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
        feature_list.append(LoadConfigureationsize)
    except:
        feature_list.append(0)
    try:
        versionInformationSize=len(get_version_info(pe))
        feature_list.append(versionInformationSize)
    except:
        feature_list.append(0)
    pe.close()
    return feature_list


def quickScanprogressBarValue(value):
        if value<=100:
            global ui
            # PROGRESSBAR STYLESHEET BASE
            styleSheet = """
            QFrame{border-radius:80px;
            background: qconicalgradient(cx:0.5, cy:0.5, angle:90, stop:{STOP_1} rgba(0, 0, 0, 0), stop:{STOP_2} rgba(76, 110, 245,255));
            }
            """
            # GET PROGRESS BAR VALUE, CONVERT TO FLOAT AND INVERT VALUES
            # stop works of 1.000 to 0.000
            progress = (100 - value) / 100.0

            # GET NEW VALUES
            stop_1 = str(progress - 0.001)
            stop_2 = str(progress)
            # FIX MAX VALUE
            if value == 100:
                stop_1 = "1.000"
                stop_2 = "1.000"
            # SET VALUES TO NEW STYLESHEET
            newStylesheet = styleSheet.replace("{STOP_1}", stop_1).replace("{STOP_2}", stop_2)
            ui.quickScanprogressBarFrame.setStyleSheet(newStylesheet)
            textInProgressBar='''<html><head/><body><p><span style=\" font-size:24pt;\">{value}</span><span style=\" font-size:24pt; vertical-align:super;\">%</span></p></body></html>'''
            newTextInProgressBar=textInProgressBar.replace("{value}",str(value))
            ui.quickScanprogressBarLbl.setText(QCoreApplication.translate("MainWindow", newTextInProgressBar, None))
        else:
            pass


def customScanProgressBarValue(value):
    if value<=100:
        global ui
        # PROGRESSBAR STYLESHEET BASE
        styleSheet = """
        QFrame{border-radius:80px;
        background: qconicalgradient(cx:0.5, cy:0.5, angle:90, stop:{STOP_1} rgba(0, 0, 0, 0), stop:{STOP_2} rgba(76, 110, 245,255));
        }
        """
        # GET PROGRESS BAR VALUE, CONVERT TO FLOAT AND INVERT VALUES
        # stop works of 1.000 to 0.000
        progress = (100 - value) / 100.0

        # GET NEW VALUES
        stop_1 = str(progress - 0.001)
        stop_2 = str(progress)
        # FIX MAX VALUE
        if value == 100:
            stop_1 = "1.000"
            stop_2 = "1.000"
        # SET VALUES TO NEW STYLESHEET
        newStylesheet = styleSheet.replace("{STOP_1}", stop_1).replace("{STOP_2}", stop_2)
        ui.customScanprogressBarFrame.setStyleSheet(newStylesheet)
        textInProgressBar='''<html><head/><body><p><span style=\" font-size:24pt;\">{value}</span><span style=\" font-size:24pt; vertical-align:super;\">%</span></p></body></html>'''
        newTextInProgressBar=textInProgressBar.replace("{value}",str(value))
        ui.customScanprogressBarLbl.setText(QCoreApplication.translate("MainWindow", newTextInProgressBar, None))
    else:
        pass


def deepScanProgressBarValue(value):
    if value<=100:
        global ui
        # PROGRESSBAR STYLESHEET BASE
        styleSheet = """
        QFrame{border-radius:80px;
        background: qconicalgradient(cx:0.5, cy:0.5, angle:90, stop:{STOP_1} rgba(0, 0, 0, 0), stop:{STOP_2} rgba(76, 110, 245,255));
        }
        """
        # GET PROGRESS BAR VALUE, CONVERT TO FLOAT AND INVERT VALUES
        # stop works of 1.000 to 0.000
        progress = (100 - value) / 100.0

        # GET NEW VALUES
        stop_1 = str(progress - 0.001)
        stop_2 = str(progress)
        # FIX MAX VALUE
        if value == 100:
            stop_1 = "1.000"
            stop_2 = "1.000"
        # SET VALUES TO NEW STYLESHEET
        newStylesheet = styleSheet.replace("{STOP_1}", stop_1).replace("{STOP_2}", stop_2)
        ui.deepScanprogressBarFrame.setStyleSheet(newStylesheet)
        textInProgressBar='''<html><head/><body><p><span style=\" font-size:24pt;\">{value}</span><span style=\" font-size:24pt; vertical-align:super;\">%</span></p></body></html>'''
        newTextInProgressBar=textInProgressBar.replace("{value}",str(value))
        ui.deepScanprogressBarLbl.setText(QCoreApplication.translate("MainWindow", newTextInProgressBar, None))
    else:
        pass
    

def onStartQuickScan():
    try:
        global shared,totalThreadShared,fileScanedShared
        ui.startQuickScanBtn.hide()
        ui.cancelQuickScanBtn.show()
        ui.quickScanTotalFileLbl.show()
        ui.quickScanThreadFoundLbl.show()
        ui.quickScanTotalFileLblText.show()
        ui.quickScanThreadFoundLbl.setText("0 Threat Found")
        ui.quickScanTotalFileLblText.setText("0 Files Scaned")
        ui.quickScanThreadFoundLbl.setStyleSheet(u"border: 2px solid  #2ECC71;\n"\
    "border-radius:90px;")
        shared = multiprocessing.Queue()
        fileScanedShared = multiprocessing.Queue()
        totalThreadShared = multiprocessing.Queue()
        p1 = multiprocessing.Process(target=classficationQuickScan, args=(extract_features,get_resources,get_entropy,get_version_info,shared,fileScanedShared,totalThreadShared,hashing),daemon=True)
        p1.start()
        def runShared1():
            global shared
            while True:
                if not ui.startQuickScanBtn.isHidden():
                    return
                while not shared.empty():
                    progressValue=[10]
                    progressValue[0]=shared.get()
                    # print(threadpool.)
                    if progressValue[0]==100:
                        quickScanprogressBarValue(progressValue[0])
                        quickScanprogressBarValue(progressValue[0])
                        ui.quickScanPageopenVirusChestBtn.show()
                        ui.cancelQuickScanBtn.hide()
                        playsound('scanCompleteSound.mp3')
                        f = open("QuickScanResults.txt", "r")
                        results=f.readlines()
                        f1=open('virusChest.txt','a+')
                        for i in results:
                            # ui.virusChestResult.addItem(i.strip())
                            if i in virusChest:
                                pass
                            else:
                                f1.write(f"{i}")
                        f1.close()
                        return
                    else:
                        data = str(progressValue[0])+',quick'
                        signal.sig.emit(data)
                        # quickScanprogressBarValue(progressValue[0])
                while not totalThreadShared.empty():
                    ui.quickScanThreadFoundLbl.setText(str(totalThreadShared.get())+ui.quickScanThreadFoundLbl.text()[-13:])
                    ui.quickScanThreadFoundLbl.setStyleSheet(u"border: 2px solid red;\n"\
    "border-radius:90px;")
                while not fileScanedShared.empty():
                    ui.quickScanTotalFileLblText.setText(str(fileScanedShared.get())+ui.quickScanTotalFileLblText.text()[-13:])
        # obj=Worker(runShared1)
        # threadpool.start(obj)
        t1=Thread(target=runShared1)
        t1.start()
    except Exception as e:
        print(e)


def onStartDeepScan(): 
    try:
        global shared,totalThreadShared,fileScanedShared
        ui.startDeepScanBtn.hide()
        ui.deepScanTotalFileLblText.show()
        ui.cancelDeepScanBtn.show()
        ui.deepScanTotalFileLbl.show()
        ui.deepScanThreadFoundLbl.show()
        ui.deepScanThreadFoundLbl.setText("0 Threat Found")
        ui.deepScanTotalFileLblText.setText("0 Files Scaned")
        ui.deepScanThreadFoundLbl.setStyleSheet(u"border: 2px solid  #2ECC71;\n"\
    "border-radius:90px;")
        shared = multiprocessing.Queue()
        fileScanedShared = multiprocessing.Queue()
        totalThreadShared = multiprocessing.Queue()
        p1 = multiprocessing.Process(target=classficationDeepScan, args=(extract_features,get_resources,get_entropy,get_version_info,shared,fileScanedShared,totalThreadShared,hashing),daemon=True)
        p1.start()
        def runShared():
            global shared
            while True:
                if not ui.startDeepScanBtn.isHidden():
                    return
                while not shared.empty():
                    progressValue=[10]
                    progressValue[0]=shared.get()
                    if progressValue[0]==100:
                        deepScanProgressBarValue(progressValue[0])
                        deepScanProgressBarValue(progressValue[0])
                        ui.deepScanPageopenVirusChestBtn.show()
                        ui.cancelDeepScanBtn.hide()
                        playsound('scanCompleteSound.mp3')
                        f = open("DeepScanResults.txt", "r")
                        results=f.readlines()
                        f1=open('virusChest.txt','a+')
                        for i in results:
                            # ui.virusChestResult.addItem(i.strip())
                            if i in virusChest:
                                pass
                            else:
                                f1.write(f"{i}")
                        f.close()
                        return
                    else:
                        # deepScanProgressBarValue(progressValue[0])
                        data = str(progressValue[0])+',deep'
                        signal.sig.emit(data)
                while not totalThreadShared.empty():
                    ui.deepScanThreadFoundLbl.setText(str(totalThreadShared.get())+ui.deepScanThreadFoundLbl.text()[-13:])
                    ui.deepScanThreadFoundLbl.setStyleSheet(u"border: 2px solid red;\n"
    "border-radius:90px;")
                while not fileScanedShared.empty():
                    ui.deepScanTotalFileLblText.setText(str(fileScanedShared.get())+ui.deepScanTotalFileLblText.text()[-13:])
        # obj=Worker(runShared)
        # threadpool.start(obj)
        t1=Thread(target=runShared)
        t1.start()
    except Exception as e:
        print(e)


def onCustomStartBtn():
    try:
        global shared
        if ui.customScanLineEdit.text()=='':
            return
        dir=ui.customScanLineEdit.text()
        ui.startCustomScanBtn.hide()
        ui.cancelCustomScanBtn.show()
        shared = multiprocessing.Queue()
        p1 = multiprocessing.Process(target=classificationCustomScan, args=(extract_features,get_resources,get_entropy,get_version_info,shared,dir),daemon=True)
        p1.start()
        def runShared():
            global shared
            while True:
                if not ui.startCustomScanBtn.isHidden():
                    return
                while not shared.empty():
                    progressValue=[10]
                    progressValue[0]=shared.get()
                    if progressValue[0]==100:
                        customScanProgressBarValue(progressValue[0])
                        customScanProgressBarValue(progressValue[0])
                        ui.customScanPageopenVirusChestBtn.show()
                        ui.cancelCustomScanBtn.hide()
                        playsound('scanCompleteSound.mp3')
                        f = open("CustomScanResults.txt", "r")
                        results=f.readlines()
                        f1=open('virusChest.txt','a+')
                        for i in results:
                            # ui.virusChestResult.addItem(i.strip())
                            if i in virusChest:
                                pass
                            else:
                                f1.write(f"{i}")
                        f1.close()
                        return
                    else:
                        # customScanProgressBarValue(progressValue[0])
                        data = str(progressValue[0])+',custom'
                        signal.sig.emit(data)
        # obj=Worker(runShared)
        # threadpool.start(obj)
        t1=Thread(target=runShared)
        t1.start()
    except:
        pass


def onQuickScanCancel():
    try:
        ui.quickScanTotalFileLbl.hide()
        ui.quickScanTotalFileLblText.hide()
        ui.quickScanThreadFoundLbl.hide()
        ui.cancelQuickScanBtn.hide()
        ui.startQuickScanBtn.show()
        quickScanprogressBarValue(0)
        pid=os.getpid()
        parent = psutil.Process(pid)
        for child in parent.children(recursive=True):
            print( "child", child)
            child.kill()
        p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
        p1.start()
    except:
        pass


def onCustomScanCancel():
    try:
        ui.cancelCustomScanBtn.hide()
        ui.startCustomScanBtn.show()
        customScanProgressBarValue(0)
        pid=os.getpid()
        parent = psutil.Process(pid)
        for child in parent.children(recursive=True):
            print( "child", child)
            child.kill()    
        p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
        p1.start()
    except:
        pass


def onOpenVirusChestBtn():
    try:
        items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
        try:
            virusChest=set([i.strip() for i in open('virusChest.txt','r').readlines()])
        except:
            virusChest=set()
        for i in virusChest:
            if i in items:
                pass
            else:
                ui.virusChestResult.addItem(i.strip())
        ui.quickScanTotalFileLbl.hide()
        ui.quickScanTotalFileLblText.hide()
        ui.quickScanThreadFoundLbl.hide()
        ui.quickScanPageopenVirusChestBtn.hide()
        ui.cancelQuickScanBtn.hide()
        ui.startQuickScanBtn.show()
        quickScanprogressBarValue(0)
        ui.stackedWidget.setCurrentIndex(4)
        ui.virusChestResult.selectAll()
    except Exception as e:
        print(e)


def killtree(parentKill=True):
    try:
        pid=os.getpid()
        parent = psutil.Process(pid)
        for child in parent.children(recursive=True):
            print( "child", child)
            child.kill()
        if parentKill:
            parent.kill()
    except:
        pass


def onCancel():
    f=open('processes.txt','a+')
    for i in []:
        f.write(i+'\n')
    f.close()
    tray.setVisible(False)
    pid=os.getpid()
    parent = psutil.Process(pid)
    for child in parent.children(recursive=True):
        print( "child", child)
        child.kill()
    parent.kill()


def onVirusChestActionApplyBtn():
    try:
        global virusChest,ignoreFile
        path=''
        if ui.virusChestActionComboBox.currentText()==' Delete':
            selectedItems=ui.virusChestResult.selectedItems()
            for file in selectedItems:
                path = file.text().replace('\\','/')
                if os.path.exists(path):
                    for proc in psutil.process_iter():
                        if proc.name() == os.path.basename(path):
                            proc.kill()
                    os.remove(path)
            for file in selectedItems:
                ui.virusChestResult.takeItem(ui.virusChestResult.row(file))
            items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
            f = open('virusChest.txt','w+')
            for i in items:
                f.write(f'{i}\n')
            f.close()
        elif ui.virusChestActionComboBox.currentText()==' Quarantine':
            pid=os.getpid()
            parent = psutil.Process(pid)
            for child in parent.children(recursive=True):
                child.kill()
            f1=open('qurantine.txt','a+')
            selectedItems=ui.virusChestResult.selectedItems()
            for i in selectedItems:
                try:
                    path = i.text().replace('\\','/')
                    qurantineFile=path
                    try:
                        pe = pefile.PE(f"{qurantineFile}")
                        f1.write(f'{qurantineFile},{pe.sections[0].Misc}\n')
                        pe.sections[0].Misc = 0x1EEC8987                        
                        newFile = os.path.dirname(qurantineFile)+'/M_'+os.path.basename(qurantineFile)
                        pe.write(newFile)
                        pe.close()
                        if os.path.exists(qurantineFile):
                            for proc in psutil.process_iter():
                                if proc.name() == os.path.basename(qurantineFile):
                                    proc.kill()
                            os.remove(qurantineFile)
                    except Exception as e:
                        print(e)
                    for file in selectedItems:
                        ui.virusChestResult.takeItem(ui.virusChestResult.row(file))
                    items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
                    f = open('virusChest.txt','w+')
                    for i in set(items):
                        f.write(f'{i}\n')
                    f.close()
                    ui.qurantineResults.addItem(qurantineFile)
                except Exception as e:
                    print(e)
            f1.close()
            # f=open('qurantine.txt','r')
            # data = set(f.readlines())
            # for i in data:
            #     print('added: ',i)
            #     ui.qurantineResults.addItem(i.strip().split(',')[0])
            # f.close()
            p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
            p1.start()
            return
        elif ui.virusChestActionComboBox.currentText()==' Ignore':
            f=open('Ignore.txt','a+')
            selectedItems=ui.virusChestResult.selectedItems()
            for i in selectedItems:
                ignoreFile=os.path.basename(i.text())
                f.write(f'{ignoreFile}\n')
            for file in selectedItems:
                ui.virusChestResult.takeItem(ui.virusChestResult.row(file))
            f.close()
            items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
            f = open('virusChest.txt','w+')
            for i in set(items):
                f.write(f'{i}\n')
            f.close()
    except Exception as e:
        print(e)


def onCustomScanChoseFolder():
    try:
        folderPath = QFileDialog.getExistingDirectory()
        ui.customScanLineEdit.setText(folderPath)
    except:
        pass


def onCustomScanVirusChestBtn():
    try:
        items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
        try:
            virusChest=set([i.strip() for i in open('virusChest.txt','r')])
        except Exception as e:
            print(e)
            virusChest=set()
        for i in virusChest:
            if i in items:
                pass
            else:
                ui.virusChestResult.addItem(i.strip())
        customScanProgressBarValue(0)
        ui.customScanPageopenVirusChestBtn.hide()
        ui.cancelCustomScanBtn.hide()
        ui.startCustomScanBtn.show()
        ui.stackedWidget.setCurrentIndex(4)
    except Exception as e:
        print(e)


def onDeepScanVirusChestBtn():
    try:
        items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
        try:
            virusChest=set([i.strip() for i in open('virusChest.txt','r')])
        except:
            virusChest=set()
        for i in virusChest:
            if i in items:
                pass
            else:
                ui.virusChestResult.addItem(i.strip())
        ui.deepScanTotalFileLbl.hide()
        ui.deepScanThreadFoundLbl.hide()
        ui.deepScanPageopenVirusChestBtn.hide()
        ui.deepScanTotalFileLblText.hide()
        ui.cancelDeepScanBtn.hide()
        ui.startDeepScanBtn.show()
        # deepScanProgressBarValue
        deepScanProgressBarValue(0)
        ui.stackedWidget.setCurrentIndex(4)
        ui.virusChestResult.selectAll()
    except Exception as e:
        print(e)


def onDeepScanCancle():
    try:
        ui.deepScanTotalFileLbl.hide()
        ui.deepScanThreadFoundLbl.hide()
        ui.deepScanTotalFileLblText.hide()
        ui.cancelDeepScanBtn.hide()
        ui.startDeepScanBtn.show()
        deepScanProgressBarValue(0)
        pid=os.getpid()
        parent = psutil.Process(pid)
        for child in parent.children(recursive=True):
            # print( "child", child)
            child.kill()
        p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
        p1.start()
    except Exception as e:
        print(e)


def dragPostion(event):
    global ui
    try:
        global dragPos
        dragPos = event. globalPosition() .toPoint()
    except:
        pass


def moveWindow(event):
    try:
        global dragPos
        # IF LEFT CLICK MOVE WINDOW
        if event.buttons() == Qt.LeftButton:
            MainWindow.move(MainWindow.pos() + event. globalPosition() .toPoint() - dragPos)
            dragPos = event. globalPosition() .toPoint()
            event.accept()
    except:
        pass


def __icon_activated(reason):
    try:
        if reason in (QSystemTrayIcon.Trigger, QSystemTrayIcon.DoubleClick):
            MainWindow.showNormal()
    except:
        pass


def onSystemTrayBtn():
    MainWindow.hide()


def get_size(bytes, suffix="B"):
    """
    Convert Large Bytes into Kilo, Mega, Giga
    Scale bytes to its proper format
    e.g:
        1253656 => '1.20MB'
        1253656678 => '1.17GB'
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P"]:
        if bytes < factor:
            return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor


def getSystemInfo():
    uname = platform.uname()
    ui.statusSystemInfo.addItem(f"System: {platform.system()} {platform.release()}")
    ui.statusSystemInfo.addItem(f"Node Name: {uname.node}")
    ui.statusSystemInfo.addItem(f"Release: {uname.release}")
    ui.statusSystemInfo.addItem(f"Version: {uname.version}")
    ui.statusSystemInfo.addItem(f"Machine: {uname.machine}")
    ui.statusSystemInfo.addItem(f"Processor: {uname.processor}")
    boot_time_timestamp = psutil.boot_time()
    bt = datetime.fromtimestamp(boot_time_timestamp)
    ui.statusSystemInfo.addItem(f"Boot Time: {bt.year}/{bt.month}/{bt.day} {bt.hour}:{bt.minute}:{bt.second}")


def getCPUInfo():
    def runShared():
        if ui.statusTabWidget.currentIndex()!= 1:
            return
        while True:
            if ui.statusTabWidget.currentIndex()!= 1:
                return
            ui.statusProcessorInfo.clear()
            # number of cores
            ui.statusProcessorInfo.addItem(f"Physical cores: {psutil.cpu_count(logical=False)}")
            ui.statusProcessorInfo.addItem(f"Total cores: {psutil.cpu_count(logical=True)}")
            # CPU frequencies
            cpufreq = psutil.cpu_freq()
            ui.statusProcessorInfo.addItem(f"Max Frequency: {cpufreq.max:.2f}Mhz")
            ui.statusProcessorInfo.addItem(f"Min Frequency: {cpufreq.min:.2f}Mhz")
            ui.statusProcessorInfo.addItem(f"Current Frequency: {cpufreq.current:.2f}Mhz")
            # CPU usage
            # ui.statusProcessorInfo.addItem("CPU Usage Per Core:")
            # for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
            #     ui.statusProcessorInfo.addItem(f"Core {i}: {percentage}%")
            ui.statusProcessorInfo.addItem(f"Total CPU Usage: {psutil.cpu_percent()}%")
            time.sleep(2)
    obj=Worker(runShared)
    threadpool.start(obj)


def getRamInfo():
    if ui.statusTabWidget.currentIndex()!= 2:
            return
    def runShared():
        while True:
            if ui.statusTabWidget.currentIndex()!= 2:
                return
            ui.statusRamInfo.clear()
            # get the memory details
            svmem = psutil.virtual_memory()
            ui.statusRamInfo.addItem(f"Total: {get_size(svmem.total)}")
            ui.statusRamInfo.addItem(f"Available: {get_size(svmem.available)}")
            ui.statusRamInfo.addItem(f"Used: {get_size(svmem.used)}")
            ui.statusRamInfo.addItem(f"Percentage: {svmem.percent}%")
            time.sleep(2)
    obj=Worker(runShared)
    threadpool.start(obj)


def getDiskInfo():
    # get all disk partitions
    partitions = psutil.disk_partitions()
    for partition in partitions:
        # ui.statusDiskInfo.addItem(f"=============================== Device: {partition.device} ==============================")
        font = QFont()
        font.setFamilies([u"Arial"])
        font.setPointSize(10)
        font.setBold(True)
        brush = QBrush(QColor(255, 255, 255, 255))
        brush.setStyle(Qt.NoBrush)
        brush1 = QBrush(QColor(76, 110, 245, 255))
        brush1.setStyle(Qt.SolidPattern)
        qlistwidgetitem = QListWidgetItem()
        qlistwidgetitem.setTextAlignment(Qt.AlignCenter);
        qlistwidgetitem.setFont(font);
        qlistwidgetitem.setBackground(brush1);
        qlistwidgetitem.setForeground(brush);
        qlistwidgetitem.setFlags(Qt.NoItemFlags);
        qlistwidgetitem.setText(f"Device: {partition.device}")
        ui.statusDiskInfo.addItem(qlistwidgetitem)

        ui.statusDiskInfo.addItem(f"File system type: {partition.fstype}")
        try:
            partition_usage = psutil.disk_usage(partition.mountpoint)
        except PermissionError:
            # this can be catched due to the disk that
            # isn't ready
            continue
        ui.statusDiskInfo.addItem(f"  Total Size: {get_size(partition_usage.total)}")
        ui.statusDiskInfo.addItem(f"  Used: {get_size(partition_usage.used)}")
        ui.statusDiskInfo.addItem(f"  Free: {get_size(partition_usage.free)}")
        ui.statusDiskInfo.addItem(f"  Percentage: {partition_usage.percent}%")


def getNetworkInfo():
    # Network information
    # get all network interfaces (virtual and physical)
    if_addrs = psutil.net_if_addrs()
    for interface_name, interface_addresses in if_addrs.items():
        # ui.statusNetworkInfo.addItem(f"\n================== Interface: {interface_name} ===================")

        font = QFont()
        font.setFamilies([u"Arial"])
        font.setPointSize(10)
        font.setBold(True)
        brush = QBrush(QColor(255, 255, 255, 255))
        brush.setStyle(Qt.NoBrush)
        brush1 = QBrush(QColor(76, 110, 245, 255))
        brush1.setStyle(Qt.SolidPattern)
        qlistwidgetitem = QListWidgetItem()
        qlistwidgetitem.setTextAlignment(Qt.AlignCenter);
        qlistwidgetitem.setFont(font);
        qlistwidgetitem.setBackground(brush1);
        qlistwidgetitem.setForeground(brush);
        qlistwidgetitem.setFlags(Qt.NoItemFlags);
        qlistwidgetitem.setText(f"Interface: {interface_name}")
        ui.statusNetworkInfo.addItem(qlistwidgetitem)

        for address in interface_addresses:
            if str(address.family) == 'AddressFamily.AF_INET':
                ui.statusNetworkInfo.addItem(f"  IP Address: {address.address}")
                ui.statusNetworkInfo.addItem(f"  Netmask: {address.netmask}")
                ui.statusNetworkInfo.addItem(f"  Broadcast IP: {address.broadcast}")
            elif str(address.family) == 'AddressFamily.AF_PACKET':
                ui.statusNetworkInfo.addItem(f"  MAC Address: {address.address}")
                ui.statusNetworkInfo.addItem(f"  Netmask: {address.netmask}")
                ui.statusNetworkInfo.addItem(f"  Broadcast MAC: {address.broadcast}")
    # get IO statistics since boot
    net_io = psutil.net_io_counters()
    # ui.statusNetworkInfo.addItem(f"\n======================= Total Send and Recieve =======================")

    font = QFont()
    font.setFamilies([u"Arial"])
    font.setPointSize(10)
    font.setBold(True)
    brush = QBrush(QColor(255, 255, 255, 255))
    brush.setStyle(Qt.NoBrush)
    brush1 = QBrush(QColor(76, 110, 245, 255))
    brush1.setStyle(Qt.SolidPattern)
    qlistwidgetitem = QListWidgetItem()
    qlistwidgetitem.setTextAlignment(Qt.AlignCenter);
    qlistwidgetitem.setFont(font);
    qlistwidgetitem.setBackground(brush1);
    qlistwidgetitem.setForeground(brush);
    qlistwidgetitem.setFlags(Qt.NoItemFlags);
    qlistwidgetitem.setText(f"Total Send and Recieve")
    ui.statusNetworkInfo.addItem(qlistwidgetitem)

    ui.statusNetworkInfo.addItem(f"Total Bytes Sent: {get_size(net_io.bytes_sent)}")
    ui.statusNetworkInfo.addItem(f"Total Bytes Received: {get_size(net_io.bytes_recv)}")


def onSettingBtn():
    ui.settingBtn.hide()
    ui.realTimeProtectionLbl.show()
    ui.realTimeProctectionSwitch.show()
    ui.menuCancel.show()


def onMenuCancel():
    ui.settingBtn.show()
    ui.realTimeProtectionLbl.hide()
    ui.realTimeProctectionSwitch.hide()
    ui.menuCancel.hide()


class MonitorEventHandling(FileSystemEventHandler):
    global virusChest
    def on_created(self, event):
        path = event.src_path
        filePath=''
        for j in path:
            if j=='\\':
                filePath+='/'
            else:
                filePath+=j
        locationToSplit=filePath[::-1].find('/')
        ignoreFile=filePath[::-1][:locationToSplit][::-1]
        qurantine = ['M_'+os.path.basename(i.strip().split(',')[0]) for i in open('qurantine.txt','r').readlines()]
        # print('qurantine Files',qurantine)
        if (ignoreFile in ignorFiles) or (os.path.basename(filePath) in qurantine):
            pass
        else:
            time.sleep(0.1)
            clf = pickle.load(open('CLF_RandomForest_99.2.sav', 'rb'))
            copyDone=False
            while copyDone!=True:
                if os.path.isfile(filePath):
                    try:
                        checkExe = open(filePath,"rb")
                        copyDone=True
                    except:
                        time.sleep(0.1)
                else:
                    break
            if copyDone==True:
                if checkExe.read(2) == b'MZ':
                    prediction=clf.predict([extract_features(pefile.PE(filePath))])
                    if prediction[0]==0:
                        prediction='Malware'
                        try:
                            checkExe.close()
                            f1=open('virusChest.txt','a+')
                            if filePath in virusChest:
                                pass
                            else:
                                f1.write(f"{filePath}\n")
                                playsound('virusDetectedSound.mp3')
                                virusChest.add(filePath)
                            f1.close()
                        except Exception as e: 
                            print(e)
                    else:
                        prediction='Clean'
                else:
                    pass

def driveMonitoring(extract_features,get_resources,get_entropy,get_version_info):
    f = open('processes.txt','a+')
    f.write(f"{multiprocessing.current_process().name} {os.getpid()}\n")
    f.close()
    event_handler = MonitorEventHandling()
    # Create Observer to watch directories
    observer = Observer()

    # Take in list of paths. If none given, watch CWD
    desktop = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Desktop').replace('\\','/')
    download = os.path.join(os.path.join(os.environ['USERPROFILE']), 'Downloads').replace('\\','/')
    paths = ['%s:/' % d for d in string.ascii_uppercase if os.path.exists('%s:/' % d)][1:]
    paths.append(desktop)
    paths.append(download)
    for i in paths:
        if os.path.exists(i):
            pass
        else:
            paths.remove(i)
    print(paths)
    # Empty list of observers
    observers = []

    # Iterate through paths and attach observers
    for line in paths:

        # Convert line into string and strip newline character
        targetPath = str(line).rstrip()

        # Schedules watching of a given path
        observer.schedule(event_handler, targetPath,recursive=True)

        # Add observable to list of observers
        observers.append(observer)

    # Start observer
    observer.start()

    try:
        while True:

            # Poll every second
            time.sleep(0.1)

    except KeyboardInterrupt:
        for o in observers:
            o.unschedule_all()

            # Stop observer if interrupted
            o.stop()

    for o in observers:

        # Wait until the thread terminates before exit
        o.join()


def onRealTimeSwitch():
    val=ui.realTimeProctectionSwitch.value()
    if val==1:
        ui.realTimeProctectionSwitch.setStyleSheet(u"QSlider::groove:horizontal {\n"
    "	background-color:rgb(114, 148, 222);\n"
    "	padding:2px;\n"
    "	border-radius:10px;\n"
    "}\n"
    "QSlider::handle:horizontal {\n"
    "      background:#051F2B;\n"
    "    width: 15px;\n"
    "    height: 10px;\n"
    "    margin: 0px ; /* handle is placed by default on the contents rect of the groove. Expand outside the groove */\n"
    "    border-radius: 7px;\n"
    "}\n"
    "")
        p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
        p1.start()
    else:
        ui.realTimeProctectionSwitch.setStyleSheet(u"QSlider::groove:horizontal {\n"
    "	background-color:#9c9c9c;\n"
    "	padding:2px;\n"
    "	border-radius:10px;\n"
    "}\n"
    "QSlider::handle:horizontal {\n"
    "      background:#051F2B;\n"
    "    width: 15px;\n"
      "    height: 10px;\n"
    "    margin: 0px ; /* handle is placed by default on the contents rect of the groove. Expand outside the groove */\n"
    "    border-radius: 7px;\n"
    "}\n"
    "")
        f=open('processes.txt','r')
        processes=[i.strip().split(' ') for i in f.readlines()]
        f.close()
        for i,j in enumerate(processes):
            if j[0]=='monitorDrives':
                p = psutil.Process(int(j[1]))
                p.terminate()
                processes.pop(i)
                break
        f=open('processes.txt','a+')
        for i in processes:
            f.write(i+'\n')
        f.close()


def onVirusChestBtn():
    try:
        items = [ui.virusChestResult.item(x).text() for x in range(ui.virusChestResult.count())]
        try:
            virusChest=set([i.strip() for i in open('virusChest.txt','r')])
        except:
            virusChest=set()
        for i in virusChest:
            if i in items:
                pass
            else:
                ui.virusChestResult.addItem(i.strip())
        ui.stackedWidget.setCurrentIndex(4)
        ui.virusChestResult.selectAll()
    except Exception as e:
        print(e)


def onUnQurantineBtn():
    selectedItems=ui.qurantineResults.selectedItems()
    qFile = open('qurantine.txt','r')
    d = list(set(qFile.readlines()))
    tempQurantine = [i.strip().split(',') for i in d]
    qFile.close()
    try:
        for file in selectedItems:
            lockFiles = [i.strip().split(',') for i in open('qurantine.txt','r').readlines()]
            misc = [i for i,j in enumerate(lockFiles) if j[0]==file.text()][0]
            f = os.path.dirname(file.text())+'/M_'+os.path.basename(file.text())
            if os.path.exists(f):
                pe = pefile.PE(f"{f}")
                r = int([i.strip().split(',')[1] for i in open('qurantine.txt','r').readlines()][misc])
                pe.sections[0].Misc = r
                newFile = file.text()
                pe.write(newFile)
                pe.close()
                os.remove(f)
            a=str(file.text())
            ui.virusChestResult.addItem(a)
            fi=open('virusChest.txt','a+')
            data = set([i for i in fi.readlines()])
            data.add(a+'\n')
            for i in data:
                fi.write(i)
            # fi.write(a+'\n')
            fi.close()
            for i,j in enumerate(tempQurantine):
                if file.text() == j[0]:
                    tempQurantine.pop(i)
        
        f = open("qurantine.txt", "w")
        for i in tempQurantine:
            f.write(','.join(i)+'\n')
        f.close()
    except Exception as e:
        exception_type, exception_object, exception_traceback = sys.exc_info()
        print(exception_type,exception_traceback.tb_lineno)
    for file in selectedItems:
        ui.qurantineResults.takeItem(ui.qurantineResults.row(file))

def locateUsb():
    drive_list = []
    while True:
        drivebits = win32file.GetLogicalDrives()
        for d in range(1, 26):
            mask = 1 << d
            if drivebits & mask:
                # here if the drive is at least there
                drname = '%c:\\' % chr(ord('A') + d)
                t = win32file.GetDriveType(drname)
                if t == win32file.DRIVE_REMOVABLE:
                    drive_list.append(drname)
        if len(drive_list)>0:
            break
    try:
        clf = pickle.load(open('CLF_RandomForest_99.2.sav', 'rb'))
        paths=[] 
        for root, dirs, files in os.walk(drive_list[0]):
            for file in files:
                if file in ignorFiles:
                    continue
                paths.append(os.path.join(root,file))
        for j,i in enumerate(paths):
            try:
                checkExe = open(i,"rb")
            except:
                pass
            if checkExe.read(2) == b'MZ':
                prediction=clf.predict([extract_features(pefile.PE(i))])
                if prediction[0]==0:
                    prediction='Malware'
                    if prediction=='Malware':
                        f1=open('virusChest.txt','a+')
                        if i in virusChest:
                            pass
                        else:
                            f1.write(f"{i}\n")
                            virusChest.add(i)
                        f1.close()
                        playsound('virusDetectedSound.mp3')
                else:
                    prediction='Clean'
        playsound('driveScan.mp3')
    except Exception as e:
        print(e)


def usbScan():
    p = multiprocessing.Process(name='usbScan',target=locateUsb,daemon=True)
    p.start()

def onOpenLink():
    def run():  
        # webbrowser.open('https://scanware.herokuapp.com/')
        webbrowser.open('#')
    obj=Worker(run)
    threadpool.start(obj)

def onOpenAbout():
    # def run():  
    #     webbrowser.open('https://scanware.herokuapp.com/#team')
    # obj=Worker(run)
    # threadpool.start(obj)
    dialog = QDialog()
    dialog.ui = Ui_aboutUs.Ui_Frame()
    dialog.ui.setupUi(dialog)
    dialog.setWindowFlags(QtCore.Qt.FramelessWindowHint)
    dialog.setAttribute(QtCore.Qt.WA_DeleteOnClose)
    dialog.setFixedHeight(400)
    dialog.setFixedWidth(510)
    dialog.move(MainWindow.pos().x()+160,MainWindow.pos().y()+110)
    dialog.ui.aboutUsCancel.clicked.connect(dialog.close)
    dialog.exec()

def onSignal(data):
    data,func=data.split(',')
    if func=='quick':
        quickScanprogressBarValue(int(data))
    elif func=='deep':
        deepScanProgressBarValue(int(data))
    elif func=='custom':
        customScanProgressBarValue(int(data))

if __name__ == '__main__':
    multiprocessing.freeze_support()
    app = Ui_smartMalwareDetection.QApplication(sys.argv)
    MainWindow = Ui_smartMalwareDetection.QWidget()
    MainWindow.setWindowFlags(Qt.WindowFlags(Qt.FramelessWindowHint))
    ui.setupUi(MainWindow)
    usbScan()
    for i in virusChest:
        ui.virusChestResult.addItem(i.strip())
    for i in lockFiles:
        ui.qurantineResults.addItem(i)
    ui.cancelBtn.clicked.connect(onCancel)
    MainWindow.mouseMoveEvent = moveWindow
    MainWindow.mousePressEvent = dragPostion
    ui.titleMinimizeBtn.clicked.connect(lambda: MainWindow.showMinimized())
    ui.stackedWidget.setCurrentIndex(0)

    p1 = multiprocessing.Process(name='monitorDrives',target=driveMonitoring, args=(extract_features,get_resources,get_entropy,get_version_info),daemon=True)
    p1.start()
    

    # Status Signal and Slots
    ui.statusBtn.clicked.connect(lambda: ui.stackedWidget.setCurrentIndex(0))
    getSystemInfo()
    ui.statusTabWidget.currentChanged.connect(getCPUInfo)
    ui.statusTabWidget.currentChanged.connect(getRamInfo)
    getNetworkInfo()
    getDiskInfo()
    

    # Quick Scan Signal and Slots
    quickScanprogressBarValue(0)
    ui.quickScanTotalFileLbl.hide()
    ui.quickScanThreadFoundLbl.hide()
    ui.quickScanTotalFileLblText.hide()
    ui.cancelQuickScanBtn.hide()
    ui.quickScanPageopenVirusChestBtn.hide()
    ui.quickScanBtn.clicked.connect(lambda: ui.stackedWidget.setCurrentIndex(2))
    ui.startQuickScanBtn.clicked.connect(onStartQuickScan)
    ui.cancelQuickScanBtn.clicked.connect(onQuickScanCancel)
    ui.quickScanPageopenVirusChestBtn.clicked.connect(onOpenVirusChestBtn)    


    # Custom Scan Signals
    ui.cancelCustomScanBtn.hide()
    ui.customScanPageopenVirusChestBtn.hide()
    customScanProgressBarValue(0)
    ui.customScanBtn.clicked.connect(lambda: ui.stackedWidget.setCurrentIndex(3))
    ui.customScanOpenFolderBtn.clicked.connect(onCustomScanChoseFolder)
    ui.startCustomScanBtn.clicked.connect(onCustomStartBtn)
    ui.customScanPageopenVirusChestBtn.clicked.connect(onCustomScanVirusChestBtn)
    ui.cancelCustomScanBtn.clicked.connect(onCustomScanCancel)


    # Deep Scan Signals and Slots
    ui.deepScanBtn.clicked.connect(lambda: ui.stackedWidget.setCurrentIndex(1))
    ui.deepScanThreadFoundLbl.hide()
    ui.deepScanTotalFileLbl.hide()
    ui.deepScanTotalFileLblText.hide()
    ui.deepScanPageopenVirusChestBtn.hide()
    ui.deepScanPageopenVirusChestBtn.clicked.connect(onDeepScanVirusChestBtn)
    ui.cancelDeepScanBtn.hide()
    deepScanProgressBarValue(0)
    ui.startDeepScanBtn.clicked.connect(onStartDeepScan)
    ui.cancelDeepScanBtn.clicked.connect(onDeepScanCancle)


    # Virus Chest Signal and Slots
    ui.virusChestBtn.clicked.connect(onVirusChestBtn)
    ui.virusChestActionApplyBtn.clicked.connect(onVirusChestActionApplyBtn)


    # System Tray Icon
    tray = QSystemTrayIcon()
    icon = QIcon("icon.png")
    tray.setIcon(icon)
    tray.setVisible(True)


    # Create the menu
    menu = QMenu()
    action = QAction("")
    menu.addAction(action)
    quit = QAction("Quit")
    quit.triggered.connect(onCancel)
    menu.addAction(quit)
    tray.setContextMenu(menu)
    tray.activated.connect(__icon_activated)
    ui.systemTrayBtn.clicked.connect(onSystemTrayBtn)

    # Real Time Proctecion
    ui.realTimeProtectionLbl.hide()
    ui.realTimeProctectionSwitch.hide()
    ui.menuCancel.hide()
    ui.settingBtn.clicked.connect(onSettingBtn)
    ui.menuCancel.clicked.connect(onMenuCancel)
    ui.realTimeProctectionSwitch.valueChanged.connect(onRealTimeSwitch)


    # buttons
    ui.qurantinBtn.clicked.connect(lambda: ui.stackedWidget.setCurrentIndex(5))
    ui.unQurantineBtn.clicked.connect(onUnQurantineBtn)
    ui.webBtn.clicked.connect(onOpenLink)
    ui.aboutBtn.clicked.connect(onOpenAbout)

    signal.sig.connect(onSignal)
    app.lastWindowClosed.connect(killtree)
    MainWindow.show()
    sys.exit(app.exec())
